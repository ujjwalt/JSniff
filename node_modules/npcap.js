var bindings = require('../build/Release/npcap_binding');
var os = require('os');
var events = require('events');
var util = require('util');
var buf = require('buffer');

// Set up the device list
exports.devs = function() {
    var devs = [];
    for (var key in os.networkInterfaces()) {
        devs.push(key);
    }
    return devs;
}();

/*
    What we need is a way to create sessions since they encapsulate all the information
    for capturing a single session of data.
    We'll create a session class in js that does all the heavy lifting since the JS <=> C++ bridge
    is quite expenive to cross. Bindings give access to a C++ PcapSession class which just provides access
    to libpcap in an encapsulated way. It does not do any processing.
*/

exports.modes = {
    none: 1,
    promiscous: 2,
    monitor: 3
}

exports.protocols = {
    raw: 1,
    ethernet: 2,
    tcp: 3,
    ip: 4
}

function PcapSession(dev, mode, filter) {
    this.setup = false; // Wether the session has been setup or not
    this.started = false; // Wether the session has started or not
    if (typeof dev !== 'string')
        throw "Device should be a string";
    this.device = dev || bindings.defaultDevice(); // the device to listen on
    if (typeof mode !== 'number')
        throw "Mode should be a number";
    this.mode = mode;
    /* 
    Set the filter which is an object consisting of :-
        * protocol
        * mode
        * port
        * host
    */
    this.filter = filter;
    if (typeof filter !== 'string') {
        // Create the string
        var filterExpr = '';
        if (filter.protocol != 1) {
            var p;
            switch (filter.protocol) {
                case 2: p = 'ether';
                break;

                case 3: p = 'tcp';
                break;

                case 4: p = 'ip';
                break;

                case 5: p = 'udp';
                break;

                case 6: p = 'wlan';
            }
            filterExpr += p + ' ';
        }
        if (filter.port) {
            filterExpr+='port '+filter.port+' ';
        }
        if (filter.host) {
            filterExpr+='host '+filter.host;
        }
        this.filter = filterExpr;
    }
    this.binding = bindings.newSession(this.device, this.mode, this.filter);
    if (!this.binding || this.binding == null) {
        console.error("Could not create a session");
        process.exit(-1);
    }
    this.setup = true;
    events.EventEmitter.call(this);
}
util.inherits(PcapSession, events.EventEmitter);

// Start the session already setup
PcapSession.prototype.start = function(cb, num) {
    if (!this.setup) {
        return false;
    }
    if (typeof cb == 'function')
        this.on('packet', cb); // Register the callback
    var me = this;
    this.binding.start(function(packet) {
        var buf = new Buffer(packet.header.caplen);
        buf.write(packet.payload);
        packet.payload = buf;
        me.emit('packet', packet); // This is called whenever a packet is received
    }, num);
}

PcapSession.prototype.stop = function() {
    this.emit('close', this.stats());
    this.binding.stop();
}

PcapSession.prototype.stats = function() {
    return this.binding.stats();
}

exports.hexdump = function(pkt, protocol) {
    function lpad(str, len) {
        while (str.length < len) {
            str = "0" + str;
        }
        return str;
    }
    /* Hexdump the payload in the following format :-
        =======================================================================
        0001  00 01 02 03 04 05 06 07  08 09 0a 0b 0c 0d 0e 0f abcdefghijklmnop
        ....  .. .. .. .. .. .. .. ..  .. .. .. .. .. .. .. .. ................
        =======================================================================

        pkt contains the following fields :-
            * header
            * payload (Buffer)
    */
    var segments = Math.round(pkt.header.caplen/16);
    var dashes = '=======================================================================';
    // Print source, destination and timestamp
    console.log("Bytes: "+pkt.header.caplen);
    console.log('Timestamp: '+pkt.header.ts.sec);
    console.log(dashes);

    var totalLen = 0;
    for (var i = 1; i <= segments; i++) {
        var seq = lpad(''+i, 4)+'  ';
        var bytes = '', str=' ';
        var len = 16;
        if ((pkt.header.caplen-totalLen)<16) {
            len = (pkt.header.caplen-totalLen);
        }
        for (var j = 0; j < len; j++) {
            bytes += pkt.payload.toString('hex', i*16+j, i*16+j+1)+' ';//.toString('hex', i*16+j, 1);
            if (j == 7) {
                bytes += ' '; // Bifurcate the segment
            }
        }
        str += pkt.payload.toString('utf8', i, i+len);
        console.log(seq+bytes+str);
        totalLen+=len;
    }
    console.log(dashes);
}

exports.createSession = function(dev, mode, filter) {
    return new PcapSession(dev, mode, filter);
}
